{"noir_version":"0.30.0+af57471035e4fa7eaffa71693219df6d029dbcde","hash":15665115040121610525,"abi":{"parameters":[{"name":"shares","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"Share","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"array","length":32,"type":{"kind":"field"}}}]}},"visibility":"private"},{"name":"message","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"hash","type":{"kind":"field"},"visibility":"public"},{"name":"verifyingAddress","type":{"kind":"field"},"visibility":"public"},{"name":"signingAddress","type":{"kind":"field"},"visibility":"public"}],"param_witnesses":{"hash":[{"start":98,"end":99}],"message":[{"start":66,"end":98}],"shares":[{"start":0,"end":66}],"signingAddress":[{"start":100,"end":101}],"verifyingAddress":[{"start":99,"end":100}]},"return_type":null,"return_witnesses":[],"error_types":{}},"bytecode":"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","debug_symbols":"5dzNblRHGIThe5m1F6fq69M/3EqEIgMmsoRshE2kCHHvGYhtiDMieidSFtSOwafBPbV59VjjT4c3V68+/vbr9c3b27vDi18+Hd7dvr68v769Ob76dCh//bu795c3X17e3V9+uD+8GPLF4ermzfFP1T5fHN5ev7s6vGj988uLQ9XJE/vTiTmen2j4xI5PdHxinDoxW384Mft8fmKePDEfTyzr+YlFT7QNnxA+gTdvePOGN29484Y3b3jzhjdvePMdb77jzXe8+Y433/HmO958x5vvePMdb77jzTvevOPNO96848073rzjzTvevOPNO968480H3nzgzQfefODNB9584M0H3nzgzQfefODNJ9584s0n3nzizSfefOLNJ9584s0n3nzizRfefOHNF9584c0X3nzhzRfefOHNF9584c21bfyI+BE8uza8u7bGj+z8SOdH8PbaJn+T+fri64uvL76++Pri64uvL76++Pri64uvb76++frm65uvb76++frm65uvb76++frF1y++Poc6cakTpzpxqxPHOnGtE+c6ca8TBztxsRMnO3GzE0c7cbUTZztxtxOHO3G5E6c7cbsTxztxvRPnO3G/Ewc8ccETJzxxwxNHPHHFE2c8cccThzxxyROnPHHLE8c8cc0T5zxxzxMHPXHREyc9cdMTRz1x1RNnPXHXE4c9cdkTpz1x2xPHPXHdE+c9cd8TBz5x4RMnPnHjE0c+ceUTZz5x5xOHPnHpE6c+cesztz5z6zO3PnPrM7c+c+sztz5z6zO3PnPrM7c+c+sztz5z6zO3PnPrM7c+c+sztz5z6zO3PnPrM7c+c+sztz5z6zO3PnPrM7c+c+sztz5z6zO3PnPrM7c+c+sztz5z6zO3PnPrM7c+c+sztz5z6zO3PnPrM7c+c+sztz5z6zO3PnPrM7c+c+sztz5z6zO3PnPrM7c+c+sztz5z6zO3PnPrM7c+c+sztz5z6zO3PnPrM7c+c+sztz5z6zO3PnPrM7c+c+sztz5z6zO3PnPrM7c+c+sztz5z6zO3PnPrM7c+c+sztz5z6zO3PnPrM7c+c+sztz5z6zO3PnPrK259xa2vuPUVt77i1lfc+opbX3HrK259xa2vuPUVt77i1lfc+opbX3HrK259xa2vuPUVt77i1lfc+opbX3HrK259xa2vuPUVt77i1lfc+opbX3Hrq3M+gMvXP+MjuGd8BveMD+Ge8SncMz6Gy62vuPUVt77i1lftjM9f8/W59RW3vuLWV9z6iltfcesrbn112vrWXA9HtPlvb9nFP549voMPz9b89lZ5nnr02xI1xv7jh7V7f/wm9i//8w8f3urp4W227x/+esuKuGWLuOUeccseccsRccsZccuVcMvTP4P56W6piFtGtE+PaJ8e0T49on16RPv0iPbpEe3TI9pnRLTPiGifEdE+I6J9RkT7jIj2GRHtMyLaZ0S0z4honxnRPjOifWZE+8yI9pkR7TMj2mdGtM+MaJ8Z0T4zon1WRPusiPZZEe2zItpnRbTPimifFdE+K6J9VkT7rIT2aVtC+7QtoX3altA+bUton7a1iFsmtE/bEtqnbQnt07aE9mlbRPsoon0U0T6KaB9FtI8i2kcR7aOI9lFE+yiifRTRPo5oH0e0jyPaxxHt44j2cUT7OKJ9HNE+jmgfR7RPRbRPRbRPRbRPRbRPRbRPRbRPRbRPRbRPRbRPRbRPi2ifFtE+LaJ9WkT7tIj2aRHt0yLap0W0T4tonxbRPntE++wR7RPxe53b//p7nZvG4797/CH4v9zSs9XDw569/bdbtohb7hG37BG3HBG3nBG3XAm3PP17nbW17elQ376/5svji98vP1xfvnp3dXc88uVrH29e31/f3jy8vP/j/V9fOT77Jw==","file_map":{"28":{"source":"use crate::hash::Hasher;\nuse crate::default::Default;\n\nglobal RATE: u32 = 3;\n\nstruct Poseidon2 {\n    cache: [Field;3],\n    state: [Field;4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n\n    pub fn hash<N>(input: [Field; N], message_size: u64) -> Field {\n        if message_size == N {\n            Poseidon2::hash_internal(input, N, false)\n        } else {\n            Poseidon2::hash_internal(input, message_size, true)\n        }\n    }\n\n    fn new(iv: Field) -> Poseidon2 {\n        let mut result = Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) -> [Field; RATE] {\n        // zero-pad the cache\n        for i in 0..RATE {\n            if i >= self.cache_size {\n                self.cache[i] = 0;\n            }\n        }\n        // add the cache into sponge state\n        for i in 0..RATE {\n            self.state[i] += self.cache[i];\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n        // return `RATE` number of field elements from the sponge state.\n        let mut result = [0; RATE];\n        for i in 0..RATE {\n            result[i] = self.state[i];\n        }\n        result\n    }\n\n    fn absorb(&mut self, input: Field) {\n        if (!self.squeeze_mode) & (self.cache_size == RATE) {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            let _ = self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else if (!self.squeeze_mode) & (self.cache_size != RATE) {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        } else if self.squeeze_mode {\n            // If we're in squeeze mode, switch to absorb mode and add the input into the cache.\n            // N.B. I don't think this code path can be reached?!\n            self.cache[0] = input;\n            self.cache_size = 1;\n            self.squeeze_mode = false;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        if self.squeeze_mode & (self.cache_size == 0) {\n            // If we're in squeze mode and the cache is empty, there is nothing left to squeeze out of the sponge!\n            // Switch to absorb mode.\n            self.squeeze_mode = false;\n            self.cache_size = 0;\n        }\n        if !self.squeeze_mode {\n            // If we're in absorb mode, apply sponge permutation to compress the cache, populate cache with compressed\n            // state and switch to squeeze mode. Note: this code block will execute if the previous `if` condition was\n            // matched\n            let new_output_elements = self.perform_duplex();\n            self.squeeze_mode = true;\n            for i in 0..RATE {\n                self.cache[i] = new_output_elements[i];\n            }\n            self.cache_size = RATE;\n        }\n        // By this point, we should have a non-empty cache. Pop one item off the top of the cache and return it.\n        let result = self.cache[0];\n        for i in 1..RATE {\n            if i < self.cache_size {\n                self.cache[i - 1] = self.cache[i];\n            }\n        }\n        self.cache_size -= 1;\n        self.cache[self.cache_size] = 0;\n        result\n    }\n\n    fn hash_internal<N>(input: [Field; N], in_len: u64, is_variable_length: bool) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv : Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\nstruct Poseidon2Hasher{\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv : Field = (self._state.len() as Field)*18446744073709551616;    // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field){\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher {\n            _state: &[],\n        }\n    }\n}\n","path":"std/hash/poseidon2.nr"},"46":{"source":"use dep::std::hash::poseidon2;\n\nstruct Share {\n    x: Field,\n    y: [Field; 32]\n}\n\npub fn main(\n    shares: [Share; 2],\n    message: pub [u8; 32], // The message encoded to verify the transaction, used as flag\n    hash: pub Field,\n    verifyingAddress: pub Field, // The address of the EOA that signed the message through trusted forwarder, used as flag\n    signingAddress: pub Field // The address of the EOA that executed the transaction, used as flag\n) {\n    let mut secret: [Field; 32] = [0; 32];\n\n    // Reconstruct each secret value independently\n    for i in 0..32 {\n        // Lagrange interpolation for each secret value (simplified for 2 points)\n        let mut term0 = shares[0].y[i];\n        term0 = term0 * (-shares[1].x);\n        term0 = term0 / (shares[0].x - shares[1].x);\n\n        let mut term1 = shares[1].y[i];\n        term1 = term1 * (-shares[0].x);\n        term1 = term1 / (shares[1].x - shares[0].x);\n\n        secret[i] = term0 + term1;\n    }\n\n    let expectedHash = poseidon2::Poseidon2::hash(secret, 32);\n    assert(hash == expectedHash, \"Hash mismatch\");\n}\n","path":"/Users/anoy/Documents/Hackathon Projects/fusion-circuits/shamir_prove/src/main.nr"}},"names":["main"]}