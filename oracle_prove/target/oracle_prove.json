{"noir_version":"0.31.0+540bef3597bd3e5775c83ec2ee3c0d4463084b4c","hash":4857726004551222507,"abi":{"parameters":[{"name":"pub_key_x","type":{"kind":"array","length":32,"type":{"kind":"field"}},"visibility":"private"},{"name":"pub_key_y","type":{"kind":"array","length":32,"type":{"kind":"field"}},"visibility":"private"},{"name":"signature","type":{"kind":"array","length":64,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"hashed_message","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"tx_hash","type":{"kind":"field"},"visibility":"public"},{"name":"verifying_address","type":{"kind":"field"},"visibility":"public"},{"name":"signing_address","type":{"kind":"field"},"visibility":"public"}],"return_type":null,"error_types":{}},"bytecode":"H4sIAAAAAAAA/9VdBXRc1xF9a8nyWpYxTI7sODHb+8VyyMzMbEuWZCaZmZmZoeEGG2ywwQYbbLDBBhtssMEmnVFmc/7e7jHE8/d4/jn3vL13d9+/mvfeSPr7903I/Xo0Czl3hzymhy6J0JwQ9vEWwFsCbwW8NfA2wNsCbwe8PfAOwDsC7wS8M/AuwLsC7wa8O/AewHsC7wW8N/A+wPsC7we8P/ABwAcCHwR8MPAhwIcCHwZ8OPAC4IXARwAvAl4MvAT4SOCjgI8GPgb4WODjgI8HPgH4ROCTgE8GXgp8CvCpwKcBnw58BvCZwGcBnw18DvC5wOcBnw98AfCFwBcBXwx8CfClwJcBXw58BfCVwFcBXw18DfC1wNcBXw98A/CNwDcB3wx8C/CtwLcB3w58B/CdwHcB3w18D/C9wPcB3w/8gPDy7tcjWVp+Pt3FHiFpm0sbObbDU+wrEpTHkAGP5Qx4TDLgMdmAx/IGPKYY8FjBgMewAY8VDXhMNeCxkgGPaQY8VjbgsYoBj1UNeKxmwGN1Ax5rGPB4ggGPJxrweJIBjycb8HiKAY+nGvB4mgGPpxvweIYBj2ca8HiWAY81DXg8W9FjIq5FphuIaS0DHmsb8HiOAY91DHg814DH8wx4rGvAYz0DHusb8NjAgMeGBjw2MuCxsQGPTQx4bGrAY8SAR8+AxwwDHjMNeMwy4DHbgMccAx5zDXjMM+Ax34DHZgY8nm/A4wUGPF5owONFBjxerOjRfz9gUH6bG4hpCwMeWxrw2MqAx9YGPLYx4LGtAY/tDHhsb8BjBwMeOxrw2MmAx84GPHYx4LGrAY/dDHjsbsBjDwMeexrw2MuAx94GPPYx4LGvAY/9DHjsb8DjAAMeBxrwOMiAx8EGPA4x4HGoAY/DDHgcbsBjgQGPhQY8jjDgsciAx2IDHksMeBxpwOMoAx5HG/A4xoDHsQY8jjPgcbwBjxMMeJxowOMkAx4nG/BYasDjFAMepxrwOM2Ax+kGPM4w4HGmAY+zDHicbcDjHAMe5xrwOM+Ax/kGPC5Q9JiI72UvNBDTRQY8LjbgcYkBj0sNeFxmwONyAx5XGPC40oDHVQY8rjbgcY0Bj2sNeFxnwON6Ax43GPC40YDHTQY8bjbgcYsBj1sNeNxmwON2Ax53GPC404DHXQY87jbgcY8Bj3sNeNxnwON+Ax4PKHqMeuPjUp/X3w4t0/4+MSCZkZysrOLcjGIv0yuIZOQX5mVHsrILc/K8PC87L7soIy8zszgvKy83vzA/N5LvZWUWeyXZ+Zkl0vllv9tnlheJExDepDjZ5/dn8cxtOWkvkzb6ussJVxCuJFwF7+cjSTmeioVhvMsVx+KPTn8BBRE/xaI13hWK8bvaSPwUC+p4VyrG7xqnmxz9uYDnNq/5q6W9RtqrXGwuuJZwHeF6wg0u+FygWDjIu1ZxLP7kbMxlxaJG3nWK8bvRSPwUCy551yvG7yYXXC7guc1r/kZpb5L2BhebC24m3EK4lXCbCz4XKBaW8m5WHIs/OxtzWbHolXeLYvxuNxI/xYJc3q2K8bvDBZcLeG7zmr9d2jukvc3F5oI7CXcR7ibc44LPBYqFx7w7FcfiL87GXFYsiubdpRi/e43ET7Fgm3e3Yvzuc8HlAp7bvObvlfY+ae9xsbngfsIDhAcJD7ngc4FiYTrvfsWx+KuzMZerKfb1gGL8HjYSP8WCft6DivF7xAWXC3hu85p/WNpHpH3IxeaCRwmPER4nPOGCzwWKhQu9RxXH4m/OxlxWLKroPaYYvyeNxE+x4KP3uGL8nnLB5QKe27zmn5T2KWmfcLG54GnCM4RnCc+54HOBYmFL72nFsfi7szGXFYtues8oxu95I/FTLAjqPasYvxdccLmA5zav+eelfUHa51xsLniR8BLhZcIrLvhcoFj41HtRcSz+4WzMZcWirN5LivF71Uj8FAvGei8rxu81F1wu4LnNa/5VaV+T9hUXmwteJ7xBeJPwlgs+FygWxvVeVxyLfzobc1mxaK/3hmL83jYSP8WCwt6bivF7xwWXC3hu85p/W9p3pH3LxeaCdwnvEd4nfOCCzwU1Fft6V3Es/uVszGXFos7ee4rx+9BI/NIV+3pfMX4fueByAc9tXvMfSvuRtB+42FzwMeETwqeEz1zwuaCWYl8fK47Fv52NuVxbsa9PFOP3uZH4KRYh9z5VjN8XLrhcwHOb1/zn0n4h7WcuNhd8SfiK8DXhGxd8Lqij2NeXimPxH2djLisWgve+Uozft0bip1ik3vtaMX7fueByAc9tXvPfSvudtN+42FzwPeEHwo+En1zwuaCuYl/fK47Ff52NuVxPsa8fFOP3s5H41Vfs60fF+P3igssFPLd/9uEXaX9ysbmAv7wUIpQjJIWCzwUNFPti71pjkRyyMZcbKvYVUoxfeSPxa6TYVznF+KWEgssFPLd5zZeXNkXapFBsLqhAPEyoSEhNQC5orNhXBcWxqGRkLjdR7CusGL80I/FrqthXRcX4VQ4wF1SSNZ8mbWVpUyEXVCFelVCNUD0BuSCi2FcVxbGoYWQue4p9VVWM3wlG4peh2Fc1xfidGGAuqCFr/gRpT5S2OuSCk4ifTDiFcGoCckGmYl8nKY7FaUbmcpZiXycrxu90I/HLVuzrFMX4nRFgLjhN1vzp0p4h7amQC84kfhahJuHsBOSCHMW+zlQci3QjczlXsa+zFONXy0j88hT7qqkYv9oB5oJ0WfO1pK0t7dmQC84hXodwLuG8BOSCfMW+zlEci7pG5nIzxb7qKMavnpH4na/Y17mK8asfYC6oK2u+nrT1pT0PckED4g0JjQiNE5ALLlDsq4HiWDQxMpcvVOyroWL8mhqJ30WKfTVSjF8kwFzQRNZ8U2kj0jaGXOARzyBkErISkAsuVuzLUxyLbCNz+VLFvjIU45cT4FzOljmbI22mtFkwl3OJ5xHyCc3izOVyMBbH+jMfVByLXMX48Z6OIRdnE1inv4ntH5z+uvk/31pmExmYS5yhwHDH0dWyEILCqyZJnucA8i6VvNMi7xbIu9TxTmu8WxjvUsU7LfFuQbxLDe+0wruF8C4VvNMC7xbA31Lnb1rz6uZvqfI3LfnbgvwtNf6mFX9bqCaBv2mRTqhFqE3gu4X5LlW+05LvFuS71PhOK75biO9S4Tst+G4B/pSaP2nlTws5avxJC39awFep+UorXy3kq1R8pYWvFvB/qfyfFv+3wH+l8l9a/NdC9LdUC0JLQitCa0IbQltCO0J7QgdCR0InQmdCF0JXQjdCd0IPQk9CL0JvQh9CX0I/Qn/CAMJAwiDCYMIQwlDCMMJwQgGhkDCCUEQoJnAZey4Tz2XYucw5lxHnMt1cBpvLTHMZZy6TPInAZX65jC6XqeUysFxmlcuYcplQLsPJZS65jCSXaeQyiFxmcD5hgcScj4WERYTFhCWEpQQuscUlrLhEFJdg4hJHXEKIS/RwCRwuMcMlXLhEykYCl/jgEhpcooJLQHCJBS5hwCUCeAt+3uKet5DnLdp5C3TeYnw/gbfIPkjgLHOJi3NEU/osacO+59Kd0gLJKyjbmjXa+cE4HprLc9E2LHoL4S1Abym8JeithLcCvbXw1qC3Ed4G9LbC24LeTng70NsLbw96B+EdQO8ovCPonYR3Ar2z8M6gdxHeBfSuwruC3k14N9C7C+8Oeg/hPUDvKbwn6L2E9wK9t/DeoPcR3gf0vsL7gt5PeD/Q+wvvD/oA4QNAHyh8IOiDhA8CfbDwwaAPET4E9KHCh4I+TPgw0IcLHw56gfAC0AuFF4I+QvgI0IuEF4FeLLwY9BLhJaCPFD4S9FHCR4E+Wvho0McIHwP6WOFjQR8nfBzo44WPB32C8AmgTxQ+EfRJwieBPln4ZNBLhZeCPkX4FNCnCp8K+jTh00CfLnw66DOEzwB9pvCZoM8SPgv02cJngz5H+BzQ5wqfC/o84fNAny98PugLhC8AfaHwhaAvEr4I9MXCF4O+RPgS0JcKXwr6MuHLQF8ufDnoK4SvAH2l8JWgrxK+CvTVwleDvkb4GtDXCl8L+jrh60BfL3w96BuEbwB9o/CNoG8Svgn0zcI3g75F+BbQtwrfCvo24dtA3y58O+g7hO8AfafwnaDvEr4L9N3Cd4O+R/ge0PcK3wv6PuH7QN8vfD/oB4Qf8OnR5/hId1p/c0Ui3G+Sdr+yzXmyut+MMr/lA/Kbou43q8xvhYD8htX95pX5rRiAX/7nNVX6is7jSr7HqT4t+jjZpyUf4nUpPi3lEK8L+7QwvI7HaJrv+YPhWK/VfVrI9940eTyluHR6cWnf4tLRJbP8VxCi/fs1/+W0kItd11EtOY4W/dma+7QwvM7fL54z/Xc8F4bz4XPR93HMovPGH/voz1bR1w7wvd/5/DeXx5FjOfIiMf9H4tUcv6foa3jsozmFxzkUjn2PP0eG3HGecyJexL9enM+3g3hHjxTfz2kmt0YiMbk1rNZvbqF/XUU9J0Osqvhe4/egnpPlwmEK+PGPGZ5bLxYZ/OnFb2v3ULGoGMdPEL9HDhWLinHOrReLnLJ5kXoEsUiN4yc1wbFIjXNuxVjwpz9lufRwsagUx0+lBMeiUpxzK8aimM+ddgSxSIvjJy3BsUiLc27FWPCnhWUfUBwuFpXj+Kmc4FhEz3e0nsPHgecwPNY5d2ZBSH7Ww8WiShw/VRIci+j5jtZz+DjwHIbHOufO4U/vyz4YPFwsqsbxUzXBsYie72g9px4HnsPwWOfcOXwXRtmHuoeLRbU4fqolOBbV4pxbMRYj+NzVjyAW1eP4qZ7gWETPd7Se0wx6Dh8HnsPwWOfcuUV87hpHEIsacfzUSHAsavjOHdUUr09EOM9GrwdMKh09YaqDw3+RIcn3uJzPTPQ1/qSWEuf9IWmj9aNDvufC8P7oP6X/A4/lx8hl6AAA","debug_symbols":"5Z3RShtBGEbfZa+D7Mx888+sr1JKiRpLQKJoLBTx3ZvYJErdVnoKvfnuXDM/yS9HcvaA5mm4Wl08fv2y3lzfPgznn56Gm9vL5XZ9u9ldPQ1TvHzv4W652V8+bJf32+E8pRgXw2pztfsy5/y8GK7XN6vhXO3582KY2uyMJh1natHbmcW7wyXa4azGfjqa+9zR1vLhbGlT/fPhVFVPLyLig8NjPR1Oo94e3m/ZLbacHLZM4+ixZvJYM3usWTzWlMea1WPN8FjTwoHSaCFBafSwoORhQcnDgpKHBSUPC0ryWNPDgpKHBSUPC0oeFpQ8LCh7WFD2sKDsYUHZw4KyPNb0sKDsYUHZw4KyhwVlDwsqHhZUPCyoeFhQ8bCgIo81PSyoeFhQ8bCg4mFBxcOC5GFB8rAgeViQPCxI8ljTw4LkYUHysCB5WJA8LKh6WFD1sKDqYUHVw4KqPNb0sKDqYUHVw4KqhwVVDwsKDwsKDwsKDwsKDwsKeazpYUHhYUHhYUHhYUHhYUHNw4KahwU1DwtqHhbU5LGmhwU1DwtqHhbUPCyo/VcLUpqm49mcPlgz9yiHw7l3/dOaffRYM3msOW9BVf3116K8XfNlaN4pakunoam9G5p/hw4df0i7m8L0y9AUZ7/5Q9rX54oc71/f2ez7ZMtxGGr19anKeBwKMtTIUCdDExma/8cWH04lNJXRVEFTQlOIi4TASIiMhNBIiI2M2MiIjYzYyIiNjNjIiI2M2MiIjYzYyIiNgtgoiI2C2CiIjYLYKIiNgtgoiI2C2CiIDSE2hNgQYkOIDSE2hNgQYkOIDSE2hNioiI2K2KiIjYrYqIiNitioiI2K2KiIjYrYCMRGIDYCsRGIjUBsBLtHQWwEYiMQG4HYaIiNhthoiI2G2GiIjYbYaOwGFrHREBsNsdERGx2x0REbHbHRERsdsdERGx2wIRJfROKLztDL62RoIkMkvgjFF6H4IhRfhOKLUHwRii9C8UUovgjFF6H4IhRfhOKLUHwRii9C8UUovgjFF6H4IhRfhOKLUHwRii9C8UUovgjFF6H4IhRfhOKLUHwRii9C8UUovgjFF6H4IhRfhOKLUHwRii9C8UUovgjFF6H4IhRfhOKLUHwRii9C8UUovgjFF6H4IhRfhOKLUHwRii9C8UUovgjFF6H4IhRfhOKLUHwRii9C8UUovgjFF6H4IhRfhOKLUHwRii9C8UUovgjFF6H4IhRfhOKL/jq+7C6+Le/Xy4ub1f4DDPePPW4uj59nuLvcfr/7+cju7A8=","file_map":{"28":{"source":"use crate::hash::Hasher;\nuse crate::default::Default;\n\nglobal RATE: u32 = 3;\n\nstruct Poseidon2 {\n    cache: [Field;3],\n    state: [Field;4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<N>(input: [Field; N], message_size: u32) -> Field {\n        if message_size == N {\n            Poseidon2::hash_internal(input, N, false)\n        } else {\n            Poseidon2::hash_internal(input, message_size, true)\n        }\n    }\n\n    fn new(iv: Field) -> Poseidon2 {\n        let mut result = Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) -> [Field; RATE] {\n        // zero-pad the cache\n        for i in 0..RATE {\n            if i >= self.cache_size {\n                self.cache[i] = 0;\n            }\n        }\n        // add the cache into sponge state\n        for i in 0..RATE {\n            self.state[i] += self.cache[i];\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n        // return `RATE` number of field elements from the sponge state.\n        let mut result = [0; RATE];\n        for i in 0..RATE {\n            result[i] = self.state[i];\n        }\n        result\n    }\n\n    fn absorb(&mut self, input: Field) {\n        if (!self.squeeze_mode) & (self.cache_size == RATE) {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            let _ = self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else if (!self.squeeze_mode) & (self.cache_size != RATE) {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        } else if self.squeeze_mode {\n            // If we're in squeeze mode, switch to absorb mode and add the input into the cache.\n            // N.B. I don't think this code path can be reached?!\n            self.cache[0] = input;\n            self.cache_size = 1;\n            self.squeeze_mode = false;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        if self.squeeze_mode & (self.cache_size == 0) {\n            // If we're in squeze mode and the cache is empty, there is nothing left to squeeze out of the sponge!\n            // Switch to absorb mode.\n            self.squeeze_mode = false;\n            self.cache_size = 0;\n        }\n        if !self.squeeze_mode {\n            // If we're in absorb mode, apply sponge permutation to compress the cache, populate cache with compressed\n            // state and switch to squeeze mode. Note: this code block will execute if the previous `if` condition was\n            // matched\n            let new_output_elements = self.perform_duplex();\n            self.squeeze_mode = true;\n            for i in 0..RATE {\n                self.cache[i] = new_output_elements[i];\n            }\n            self.cache_size = RATE;\n        }\n        // By this point, we should have a non-empty cache. Pop one item off the top of the cache and return it.\n        let result = self.cache[0];\n        for i in 1..RATE {\n            if i < self.cache_size {\n                self.cache[i - 1] = self.cache[i];\n            }\n        }\n        self.cache_size -= 1;\n        self.cache[self.cache_size] = 0;\n        result\n    }\n\n    fn hash_internal<N>(input: [Field; N], in_len: u32, is_variable_length: bool) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv : Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\nstruct Poseidon2Hasher{\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv : Field = (self._state.len() as Field)*18446744073709551616;    // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field){\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher {\n            _state: &[],\n        }\n    }\n}\n","path":"std/hash/poseidon2.nr"},"30":{"source":"mod hash;\nmod aes128;\nmod array;\nmod slice;\nmod merkle;\nmod schnorr;\nmod ecdsa_secp256k1;\nmod ecdsa_secp256r1;\nmod eddsa;\nmod embedded_curve_ops;\nmod sha256;\nmod sha512;\nmod field;\nmod ec;\nmod unsafe;\nmod collections;\nmod compat;\nmod convert;\nmod option;\nmod string;\nmod test;\nmod cmp;\nmod ops;\nmod default;\nmod prelude;\nmod uint128;\nmod bigint;\nmod runtime;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained pub fn print<T>(input: T) {\n    print_oracle(false, input);\n}\n\nunconstrained pub fn println<T>(input: T) {\n    print_oracle(true, input);\n}\n\n#[foreign(recursive_aggregation)]\npub fn verify_proof<N>(verification_key: [Field], proof: [Field], public_inputs: [Field], key_hash: Field) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n// from_field and as_field are private since they are not valid for every type.\n// `as` should be the default for users to cast between primitive types, and in the future\n// traits can be used to work with generic types.\n#[builtin(from_field)]\nfn from_field<T>(x: Field) -> T {}\n\n#[builtin(as_field)]\nfn as_field<T>(x: T) -> Field {}\n\npub fn wrapping_add<T>(x: T, y: T) -> T {\n    crate::from_field(crate::as_field(x) + crate::as_field(y))\n}\n\npub fn wrapping_sub<T>(x: T, y: T) -> T {\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    crate::from_field(crate::as_field(x) + 340282366920938463463374607431768211456 - crate::as_field(y))\n}\n\npub fn wrapping_mul<T>(x: T, y: T) -> T {\n    crate::from_field(crate::as_field(x) * crate::as_field(y))\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\n","path":"std/lib.nr"},"47":{"source":"use std::hash::poseidon2;\n\n/**\n* @notice verify the Signature through the Oracle\n* @dev returns A secret hash based on the public key  if the signature is valid\n*/\n#[oracle(serverVerify)]\nunconstrained fn verify(\n    pub_key_x: [Field; 32],\n    pub_key_y: [Field; 32],\n    signature: [u8; 64],\n    hashed_message: [u8; 32]\n) -> Field {}\n\n/**\n* @notice unconstrained function that encloses the oracle function\n*/\nunconstrained fn server_verify(\n    pub_key_x: [Field; 32],\n    pub_key_y: [Field; 32],\n    signature: [u8; 64],\n    hashed_message: [u8; 32]\n) -> Field {\n    verify(pub_key_x, pub_key_y, signature, hashed_message)\n}\n\n/**\n* @notice main function that verifies the signature and hashes the public key and the result\n* @dev check if the provided tx_hash is equal to the hash of the public key and the result\n*/\nfn main(\n    pub_key_x: [Field; 32],\n    pub_key_y: [Field; 32],\n    signature: [u8; 64],\n    hashed_message: pub [u8; 32],\n    tx_hash: pub Field,\n    verifying_address: pub Field, // The address that is being verified, used as flag\n    signing_address: pub Field // The address that signed the message, used as flag\n) {\n    let result = server_verify(pub_key_x, pub_key_y, signature, hashed_message);\n\n    let mut combined = [0; 65];\n\n    for i in 0..65 {\n        if i < 32 {\n            combined[i] = pub_key_x[i];\n        } else if i < 64 {\n            combined[i] = pub_key_y[i - 32];\n        } else {\n            combined[i] = result;\n        }\n    }\n\n    let hash = poseidon2::Poseidon2::hash(combined, 65);\n\n    assert(hash == tx_hash);\n\n    println(verifying_address); // Used as flag to verify with the contract\n    println(signing_address); // Used as flag to verify with the contract\n}\n","path":"/Users/anoy/Documents/Hackathon Projects/fusion-circuits/oracle_proof/src/main.nr"}},"names":["main"]}