{"noir_version":"0.30.0+af57471035e4fa7eaffa71693219df6d029dbcde","hash":503176184133819817,"abi":{"parameters":[{"name":"pub_key_x","type":{"kind":"array","length":32,"type":{"kind":"field"}},"visibility":"private"},{"name":"pub_key_y","type":{"kind":"array","length":32,"type":{"kind":"field"}},"visibility":"private"},{"name":"signature","type":{"kind":"array","length":64,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"hashed_message","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"tx_hash","type":{"kind":"field"},"visibility":"public"},{"name":"verifying_address","type":{"kind":"field"},"visibility":"public"},{"name":"signing_address","type":{"kind":"field"},"visibility":"public"}],"param_witnesses":{"hashed_message":[{"start":128,"end":160}],"pub_key_x":[{"start":0,"end":32}],"pub_key_y":[{"start":32,"end":64}],"signature":[{"start":64,"end":128}],"signing_address":[{"start":162,"end":163}],"tx_hash":[{"start":160,"end":161}],"verifying_address":[{"start":161,"end":162}]},"return_type":null,"return_witnesses":[],"error_types":{}},"bytecode":"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","debug_symbols":"5Z3RShtBGEbfZa+DZGa++WfWVymlRI0lIFE0For47t1YE6VulZ6CN9+dm8xP8sORnD2geRgu1mf3379ttpfXd8Ppl4fh6vp8tdtcb6erh2GMp8fublbb/eXdbnW7G05TiroY1tuL6cec2+NiuNxcrYdTxePXxTC22RmN42GmlvH1zOLN4aL2fLb0fjya+9zRVvPhbGv1/cOp5uMbr/tXfvfwshwPL7teH95v2S22HB22TMulx5rJY83ssWbxWFMea1aPNcNjTQsHmh7yWNPDgpKHBSUPC0oeFpQ8LCjJY00PC0oeFpQ8LCh5WFDysKDsYUHZw4KyhwVlDwvK8ljTw4KyhwVlDwvKHhaUPSyoeFhQ8bCg4mFBxcOCijzW9LCg4mFBxcOCiocFFQ8LkocFycOC5GFB8rAgyWNNDwuShwXJw4LkYUHysKDqYUHVw4KqhwVVDwuq8ljTw4KqhwVVDwuqHhZUPSwoPCwoPCwoPCwoPCwo5LGmhwWFhwWFhwWFhwWFhwU1DwtqHhbUPCyoeVhQk8eaHhbUPCyoeVhQ87Cg9qkWpOn1ns8qjR+smbvK8+HcQ/+1Zl96rJk81py3oFrLcc3or9d8Gpp3itriMBTL/GZo/hM6jr+t001h/DE0xslf/pD25bWipLfv72T2c7Klw1atvCxVloehIEONDHUyNJKh+X9s8eFUQlMZTRU0JTSFuEgIjITISAiNhNjIiI2M2MiIjYzYyIiNjNjIiI2M2MiIjYzYKIiNgtgoiI2C2CiIjYLYKIiNgtgoiI2C2BBiQ4gNITaE2BBiQ4gNITaE2BBiQ4iNitioiI2K2KiIjYrYqIiNitioiI2K2KiIjUBsBGIjEBuB2AjERrB7FMRGIDYCsRGIjYbYaIiNhthoiI2G2GiIjcZuYBEbDbHREBsdsdERGx2x0REbHbHRERsdsdEBGyLxRSS+6AS9vU6GRjJE4otQfBGKL0LxRSi+CMUXofgiFF+E4otQfBGKL0LxRSi+CMUXofgiFF+E4otQfBGKL0LxRSi+CMUXofgiFF+E4otQfBGKL0LxRSi+CMUXofgiFF+E4otQfBGKL0LxRSi+CMUXofgiFF+E4otQfBGKL0LxRSi+CMUXofgiFF+E4otQfBGKL0LxRSi+CMUXofgiFF+E4otQfBGKL0LxRSi+CMUXofgiFF+E4otQfBGKL0LxRSi+CMUXofgiFF+E4otQfBGKL0LxRSi+6J/jy3TxY3W7WZ1drfdfYLh/7n57fvg+w+ly9/Pm9zPT2V8=","file_map":{"28":{"source":"use crate::hash::Hasher;\nuse crate::default::Default;\n\nglobal RATE: u32 = 3;\n\nstruct Poseidon2 {\n    cache: [Field;3],\n    state: [Field;4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n\n    pub fn hash<N>(input: [Field; N], message_size: u64) -> Field {\n        if message_size == N {\n            Poseidon2::hash_internal(input, N, false)\n        } else {\n            Poseidon2::hash_internal(input, message_size, true)\n        }\n    }\n\n    fn new(iv: Field) -> Poseidon2 {\n        let mut result = Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) -> [Field; RATE] {\n        // zero-pad the cache\n        for i in 0..RATE {\n            if i >= self.cache_size {\n                self.cache[i] = 0;\n            }\n        }\n        // add the cache into sponge state\n        for i in 0..RATE {\n            self.state[i] += self.cache[i];\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n        // return `RATE` number of field elements from the sponge state.\n        let mut result = [0; RATE];\n        for i in 0..RATE {\n            result[i] = self.state[i];\n        }\n        result\n    }\n\n    fn absorb(&mut self, input: Field) {\n        if (!self.squeeze_mode) & (self.cache_size == RATE) {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            let _ = self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else if (!self.squeeze_mode) & (self.cache_size != RATE) {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        } else if self.squeeze_mode {\n            // If we're in squeeze mode, switch to absorb mode and add the input into the cache.\n            // N.B. I don't think this code path can be reached?!\n            self.cache[0] = input;\n            self.cache_size = 1;\n            self.squeeze_mode = false;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        if self.squeeze_mode & (self.cache_size == 0) {\n            // If we're in squeze mode and the cache is empty, there is nothing left to squeeze out of the sponge!\n            // Switch to absorb mode.\n            self.squeeze_mode = false;\n            self.cache_size = 0;\n        }\n        if !self.squeeze_mode {\n            // If we're in absorb mode, apply sponge permutation to compress the cache, populate cache with compressed\n            // state and switch to squeeze mode. Note: this code block will execute if the previous `if` condition was\n            // matched\n            let new_output_elements = self.perform_duplex();\n            self.squeeze_mode = true;\n            for i in 0..RATE {\n                self.cache[i] = new_output_elements[i];\n            }\n            self.cache_size = RATE;\n        }\n        // By this point, we should have a non-empty cache. Pop one item off the top of the cache and return it.\n        let result = self.cache[0];\n        for i in 1..RATE {\n            if i < self.cache_size {\n                self.cache[i - 1] = self.cache[i];\n            }\n        }\n        self.cache_size -= 1;\n        self.cache[self.cache_size] = 0;\n        result\n    }\n\n    fn hash_internal<N>(input: [Field; N], in_len: u64, is_variable_length: bool) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv : Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\nstruct Poseidon2Hasher{\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv : Field = (self._state.len() as Field)*18446744073709551616;    // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field){\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher {\n            _state: &[],\n        }\n    }\n}\n","path":"std/hash/poseidon2.nr"},"30":{"source":"mod hash;\nmod aes128;\nmod array;\nmod slice;\nmod merkle;\nmod schnorr;\nmod ecdsa_secp256k1;\nmod ecdsa_secp256r1;\nmod eddsa;\nmod embedded_curve_ops;\nmod sha256;\nmod sha512;\nmod field;\nmod ec;\nmod unsafe;\nmod collections;\nmod compat;\nmod convert;\nmod option;\nmod string;\nmod test;\nmod cmp;\nmod ops;\nmod default;\nmod prelude;\nmod uint128;\nmod bigint;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained pub fn print<T>(input: T) {\n    print_oracle(false, input);\n}\n\nunconstrained pub fn println<T>(input: T) {\n    print_oracle(true, input);\n}\n\n#[foreign(recursive_aggregation)]\npub fn verify_proof<N>(verification_key: [Field], proof: [Field], public_inputs: [Field], key_hash: Field) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n// from_field and as_field are private since they are not valid for every type.\n// `as` should be the default for users to cast between primitive types, and in the future\n// traits can be used to work with generic types.\n#[builtin(from_field)]\nfn from_field<T>(x: Field) -> T {}\n\n#[builtin(as_field)]\nfn as_field<T>(x: T) -> Field {}\n\npub fn wrapping_add<T>(x: T, y: T) -> T {\n    crate::from_field(crate::as_field(x) + crate::as_field(y))\n}\n\npub fn wrapping_sub<T>(x: T, y: T) -> T {\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    crate::from_field(crate::as_field(x) + 340282366920938463463374607431768211456 - crate::as_field(y))\n}\n\npub fn wrapping_mul<T>(x: T, y: T) -> T {\n    crate::from_field(crate::as_field(x) * crate::as_field(y))\n}\n","path":"std/lib.nr"},"46":{"source":"use dep::std::hash::poseidon2;\n\n/**\n* @notice verify the Signature through the Oracle\n* @dev returns A secret hash based on the public key  if the signature is valid\n*/\n#[oracle(serverVerify)]\nunconstrained fn verify(\n    pub_key_x: [Field; 32],\n    pub_key_y: [Field; 32],\n    signature: [u8; 64],\n    hashed_message: [u8; 32]\n) -> Field {}\n\n/**\n* @notice unconstrained function that encloses the oracle function\n*/\nunconstrained fn server_verify(\n    pub_key_x: [Field; 32],\n    pub_key_y: [Field; 32],\n    signature: [u8; 64],\n    hashed_message: [u8; 32]\n) -> Field {\n    verify(pub_key_x, pub_key_y, signature, hashed_message)\n}\n\n/**\n* @notice main function that verifies the signature and hashes the public key and the result\n* @dev check if the provided tx_hash is equal to the hash of the public key and the result\n*/\nfn main(\n    pub_key_x: [Field; 32],\n    pub_key_y: [Field; 32],\n    signature: [u8; 64],\n    hashed_message: pub [u8; 32],\n    tx_hash: pub Field,\n    verifying_address: pub Field, // The address that is being verified, used as flag\n    signing_address: pub Field // The address that signed the message, used as flag\n) {\n    let result = server_verify(pub_key_x, pub_key_y, signature, hashed_message);\n\n    let mut combined = [0; 65];\n\n    for i in 0..65 {\n        if i < 32 {\n            combined[i] = pub_key_x[i];\n        } else if i < 64 {\n            combined[i] = pub_key_y[i - 32];\n        } else {\n            combined[i] = result;\n        }\n    }\n\n    let hash = poseidon2::Poseidon2::hash(combined, 65);\n\n    assert(hash == tx_hash);\n\n    println(verifying_address); // Used as flag to verify with the contract\n    println(signing_address); // Used as flag to verify with the contract\n}\n","path":"/Users/anoy/Documents/Hackathon Projects/fusion-circuits/oracle_prove/src/main.nr"}},"names":["main"]}