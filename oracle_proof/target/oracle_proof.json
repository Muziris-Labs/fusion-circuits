{"noir_version":"0.31.0+540bef3597bd3e5775c83ec2ee3c0d4463084b4c","hash":3034809326181778861,"abi":{"parameters":[{"name":"pub_key_x","type":{"kind":"array","length":32,"type":{"kind":"field"}},"visibility":"private"},{"name":"pub_key_y","type":{"kind":"array","length":32,"type":{"kind":"field"}},"visibility":"private"},{"name":"signature","type":{"kind":"array","length":64,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"hashed_message","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"tx_hash","type":{"kind":"field"},"visibility":"public"},{"name":"verifying_address","type":{"kind":"field"},"visibility":"private"},{"name":"signing_address","type":{"kind":"field"},"visibility":"public"}],"return_type":null,"error_types":{}},"bytecode":"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","debug_symbols":"5Z3RShtBGEbfZa+D7Mx8/8ysr1JKiRpLQKJoLBTx3buxSSo1rfQUvPnuXDO/5McDOXsgydNwtbp4/Pplvbm+fRjOPz0NN7eXy+36djNfPQ1Tffndw91ys7t82C7vt8N5SlEXw2pzNf+YU39eDNfrm9Vwrvb8eTFM7eSMpvEwE2V8PbN4c7jUtj+r8defz/3U0dby/mxpU/z9cArF8UnU+s7hMY6H06jXh3dbdostJ4ct0zh6rJk81sweaxaPNeWxZnisWT3WtHCgNFpIUBo9LCh5WFDysKDkYUHJw4KSPNb0sKDkYUHJw4KShwUlDwvKHhaUPSwoe1hQ9rCgLI81PSwoe1hQ9rCg7GFB2cOCiocFFQ8LKh4WVDwsqMhjTQ8LKh4WVDwsqHhYUPGwIHlYkDwsSB4WJA8LkjzW9LAgeViQPCxIHhYkDwsKDwsKDwsKDwsKDwsKeazpYUHhYUHhYUHhYUHhYUHVw4KqhwVVDwuqHhZU5bGmhwVVDwuqHhZUPSyoelhQ87Cg5mFBzcOCmocFNXms6WFBzcOCmocFNQ8Lah9qQUrTdDib0ztr5l7L/nDuXf+1Zh891kwea562oJCOa8b0es2XodNOEcd95y5a3gydfoWuOuwy3/u234amevaHN9JGS/uxmuvb53d28nWy5cNHt7VIx6H537gfqmSokaFOhiYydPqDLd6dSmgqo6mCpoSmEBcJgZEQGQmhkRAbGbGRERsZsZERGxmxkREbGbGRERsZsZERGwWxURAbBbFREBsFsVEQGwWxURAbBbFREBtCbAixIcSGEBtCbAixIcSGEBtCbAixEYiNQGwEYiMQG4HYCMRGIDYCsRGIjUBsVMRGRWxUxEZFbFTERmX3KIiNitioiI2K2GiIjYbYaIiNhthoiI2G2GjsBhax0RAbDbHRERsdsdERGx2x0REbHbHRERsdsCESX0Tii87Q0+tkaCJDJL4IxReh+CIUX4Tii1B8EYovQvFFKL4IxReh+CIUX4Tii1B8EYovQvFFKL4IxReh+CIUX4Tii1B8EYovQvFFKL4IxReh+CIUX4Tii1B8EYovQvFFKL4IxReh+CIUX4Tii1B8EYovQvFFKL4IxReh+CIUX4Tii1B8EYovQvFFKL4IxReh+CIUX4Tii1B8EYovQvFFKL4IxReh+CIUX4Tii1B8EYovQvFFKL4IxReh+CIUX4Tii1B8EYovQvFFKL4IxReh+CIUX4Tii/45vswX35b36+XFzWr3BYa7xx43l4fvM5wvt9/vfj4yn/0B","file_map":{"28":{"source":"use crate::hash::Hasher;\nuse crate::default::Default;\n\nglobal RATE: u32 = 3;\n\nstruct Poseidon2 {\n    cache: [Field;3],\n    state: [Field;4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<N>(input: [Field; N], message_size: u32) -> Field {\n        if message_size == N {\n            Poseidon2::hash_internal(input, N, false)\n        } else {\n            Poseidon2::hash_internal(input, message_size, true)\n        }\n    }\n\n    fn new(iv: Field) -> Poseidon2 {\n        let mut result = Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) -> [Field; RATE] {\n        // zero-pad the cache\n        for i in 0..RATE {\n            if i >= self.cache_size {\n                self.cache[i] = 0;\n            }\n        }\n        // add the cache into sponge state\n        for i in 0..RATE {\n            self.state[i] += self.cache[i];\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n        // return `RATE` number of field elements from the sponge state.\n        let mut result = [0; RATE];\n        for i in 0..RATE {\n            result[i] = self.state[i];\n        }\n        result\n    }\n\n    fn absorb(&mut self, input: Field) {\n        if (!self.squeeze_mode) & (self.cache_size == RATE) {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            let _ = self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else if (!self.squeeze_mode) & (self.cache_size != RATE) {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        } else if self.squeeze_mode {\n            // If we're in squeeze mode, switch to absorb mode and add the input into the cache.\n            // N.B. I don't think this code path can be reached?!\n            self.cache[0] = input;\n            self.cache_size = 1;\n            self.squeeze_mode = false;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        if self.squeeze_mode & (self.cache_size == 0) {\n            // If we're in squeze mode and the cache is empty, there is nothing left to squeeze out of the sponge!\n            // Switch to absorb mode.\n            self.squeeze_mode = false;\n            self.cache_size = 0;\n        }\n        if !self.squeeze_mode {\n            // If we're in absorb mode, apply sponge permutation to compress the cache, populate cache with compressed\n            // state and switch to squeeze mode. Note: this code block will execute if the previous `if` condition was\n            // matched\n            let new_output_elements = self.perform_duplex();\n            self.squeeze_mode = true;\n            for i in 0..RATE {\n                self.cache[i] = new_output_elements[i];\n            }\n            self.cache_size = RATE;\n        }\n        // By this point, we should have a non-empty cache. Pop one item off the top of the cache and return it.\n        let result = self.cache[0];\n        for i in 1..RATE {\n            if i < self.cache_size {\n                self.cache[i - 1] = self.cache[i];\n            }\n        }\n        self.cache_size -= 1;\n        self.cache[self.cache_size] = 0;\n        result\n    }\n\n    fn hash_internal<N>(input: [Field; N], in_len: u32, is_variable_length: bool) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv : Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\nstruct Poseidon2Hasher{\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv : Field = (self._state.len() as Field)*18446744073709551616;    // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field){\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher {\n            _state: &[],\n        }\n    }\n}\n","path":"std/hash/poseidon2.nr"},"30":{"source":"mod hash;\nmod aes128;\nmod array;\nmod slice;\nmod merkle;\nmod schnorr;\nmod ecdsa_secp256k1;\nmod ecdsa_secp256r1;\nmod eddsa;\nmod embedded_curve_ops;\nmod sha256;\nmod sha512;\nmod field;\nmod ec;\nmod unsafe;\nmod collections;\nmod compat;\nmod convert;\nmod option;\nmod string;\nmod test;\nmod cmp;\nmod ops;\nmod default;\nmod prelude;\nmod uint128;\nmod bigint;\nmod runtime;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained pub fn print<T>(input: T) {\n    print_oracle(false, input);\n}\n\nunconstrained pub fn println<T>(input: T) {\n    print_oracle(true, input);\n}\n\n#[foreign(recursive_aggregation)]\npub fn verify_proof<N>(verification_key: [Field], proof: [Field], public_inputs: [Field], key_hash: Field) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n// from_field and as_field are private since they are not valid for every type.\n// `as` should be the default for users to cast between primitive types, and in the future\n// traits can be used to work with generic types.\n#[builtin(from_field)]\nfn from_field<T>(x: Field) -> T {}\n\n#[builtin(as_field)]\nfn as_field<T>(x: T) -> Field {}\n\npub fn wrapping_add<T>(x: T, y: T) -> T {\n    crate::from_field(crate::as_field(x) + crate::as_field(y))\n}\n\npub fn wrapping_sub<T>(x: T, y: T) -> T {\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    crate::from_field(crate::as_field(x) + 340282366920938463463374607431768211456 - crate::as_field(y))\n}\n\npub fn wrapping_mul<T>(x: T, y: T) -> T {\n    crate::from_field(crate::as_field(x) * crate::as_field(y))\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\n","path":"std/lib.nr"},"47":{"source":"use std::hash::poseidon2;\n\n/**\n* @notice verify the Signature through the Oracle\n* @dev returns A secret hash based on the public key  if the signature is valid\n*/\n#[oracle(serverVerify)]\nunconstrained fn verify(\n    pub_key_x: [Field; 32],\n    pub_key_y: [Field; 32],\n    signature: [u8; 64],\n    hashed_message: [u8; 32]\n) -> Field {}\n\n/**\n* @notice unconstrained function that encloses the oracle function\n*/\nunconstrained fn server_verify(\n    pub_key_x: [Field; 32],\n    pub_key_y: [Field; 32],\n    signature: [u8; 64],\n    hashed_message: [u8; 32]\n) -> Field {\n    verify(pub_key_x, pub_key_y, signature, hashed_message)\n}\n\n/**\n* @notice main function that verifies the signature and hashes the public key and the result\n* @dev check if the provided tx_hash is equal to the hash of the public key and the result\n*/\nfn main(\n    pub_key_x: [Field; 32],\n    pub_key_y: [Field; 32],\n    signature: [u8; 64],\n    hashed_message: pub [u8; 32],\n    tx_hash: pub Field,\n    verifying_address: Field, // The address that is being verified, used as flag\n    signing_address: pub Field // The address that signed the message, used as flag\n) {\n    let result = server_verify(pub_key_x, pub_key_y, signature, hashed_message);\n\n    let mut combined = [0; 65];\n\n    for i in 0..65 {\n        if i < 32 {\n            combined[i] = pub_key_x[i];\n        } else if i < 64 {\n            combined[i] = pub_key_y[i - 32];\n        } else {\n            combined[i] = result;\n        }\n    }\n\n    let hash = poseidon2::Poseidon2::hash(combined, 65);\n\n    assert(hash == tx_hash);\n\n    println(verifying_address); // Used as flag to verify with the contract\n    println(signing_address); // Used as flag to verify with the contract\n}\n","path":"/Users/anoy/Documents/Hackathon Projects/fusion-circuits/oracle_proof/src/main.nr"}},"names":["main"]}